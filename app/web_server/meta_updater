#!/usr/bin/env python
from __future__ import print_function, division
import argparse
import errno
import getpass
import os
import pprint
import psycopg2
import psycopg2.extras
import re
import sys
import yaml

from PIL import Image
from six.moves import configparser


#Each histology magnification level is 4 times larger than the last
HIST_MAGNIFICATION_FACTOR = 4

class AtlasRoot:
    def __init__(self, path):
        self.path = path
        self.subjects = {}

    def add_subject(self, name, display_name, primary_key, ui_id):
        subject = self.subjects[name] = Subject(self, name, display_name,
            primary_key, ui_id)
        return subject

    def __repr__(self):
        return '<AtlasRoot {0}>'.format(self.__dict__)

    def get_pp_obj(self):
        subjects_o = {}
        for subject_name, subject in self.subjects.items():
            subjects_o[subject_name] = subject.get_pp_obj()
        return [('name', self.path, 'subjects', subjects_o)]

class Subject:
    def __init__(self, root, name, display_name, primary_key, ui_id):
        self.root = root  # Atlas path
        self.name = name
        self.display_name = display_name
        self.id = primary_key
        self.ui_id = ui_id
        self.volume = {
            'coronal': [None, None],
            'axial': [None, None],
            'sagittal': [None, None],
        }
        self.modalities = {}

    def define_modality(self, name, path, config):
        modality = self.modalities[name] = Modality(self.root, self,
            name, path, config)
        return modality

    def __repr__(self):
        return '<Subject name={0} display_name={1} id={2} ui_id={3} volume={4} modalities={5}>'.format(
            self.name, self.display_name, self.id, self.ui_id, self.volume,
            self.modalities)

    def get_pp_obj(self):
        mod_o = {}
        for modality_name, modality in self.modalities.items():
            mod_o[modality_name] = modality.get_pp_obj()
        return [
            'Subject',
            ('name', self.name),
            ('display_name', self.display_name),
            ('id', self.id),
            ('ui_id', self.ui_id),
            ('volume', self.volume),
            ('modalities', mod_o),
        ]

class Modality:
    def __init__(self, root, subject, name, path, config):
        self.root = root  # Atlas path
        self.subject = subject
        self.name = name
        self.path = path
        self.config = config
        self.axes = {}

    def define_axis(self, axis_name, axis_path, item):
        config = self.config and self.config.get(axis_name, {}) or {}
        axis = self.axes[axis_name] = ImageAxis(axis_name,
            self.subject.volume, axis_path, item, config,
            _parent=self)
        return axis

    def get_axis(self, axis_name):
        return self.axes.get(axis_name)

    def __repr__(self):
        return '<Modality name={0} path={1} config={2} axes={3}>'.format(
            self.name, self.path, self.config, self.axes)

    def get_pp_obj(self):
        axes_o = {}
        for axis_name, axis in self.axes.items():
            axes_o[axis_name] = axis.get_pp_obj()
        return ['Modality', ('name', self.name), ('path', self.path),
            ('config', self.config), ('axes', axes_o)]

class ImageAxis:
    def __init__(self, name, volume, path, item, config,
            _parent=None, _parent_axis=None):
        self.name = name
        self.volume = volume # From subject volume
        self.config = config
        self.subaxes = {}
        self._parent = _parent
        self._parent_axis = _parent_axis
        if self._parent:
            self.parent_dir = self._parent.path # Modality path
            self.root = self._parent.root
        else:
            self.parent_dir = path
            self.root = self._parent_axis.root # ImageAxis path
        self.build_from_path(path, item)

    def build_from_path(self, path, item):
        self.path = path
        self.prefix_dir = os.path.relpath(self.path, self.parent_dir)
        self.item = item
        self.paths = {}
        self.min_item = None
        self.max_item = None
        self.image_w = None
        self.image_h = None
        self.path_template = None
        return self._build_from_path(path, item, self.prefix_dir)

    def _build_from_path(self, path, item, prefix_dir, is_split_folder=False):
        #print('build from path', path)
        if not item:
            return None
        #If this is a split folder
        if os.path.exists(os.path.join(path, '0')):
            for split in os.listdir(path):
                split_path = os.path.join(path, str(split))
                if not os.path.isdir(split_path):
                    continue
                self._build_from_path(split_path, item,
                    os.path.normpath(os.path.join(prefix_dir, split)),
                    is_split_folder=True)
        else: #If this is not a prefix folder
            for item_name in os.listdir(path):
                if not item_name.startswith(item):
                    #print('bad item_name', item_name)
                    continue
                item_path = os.path.join(path, item_name)
                #print('item_path', prefix_dir, item_path)
                item_num = int(re.search('(\d+)', item_name).group(1))
                #print('item name:', item_name, 'item num:', item_num)
                if self.min_item is None or item_num < self.min_item:
                    self.min_item = item_num
                    if self.name in AXIS_NAMES:
                        axis_range = self.volume.get(self.name)
                        if axis_range[0] is None or self.min_item < axis_range[0]:
                            axis_range[0] = self.min_item
                if self.max_item is None or item_num > self.max_item:
                    self.max_item = item_num
                    if self.name in AXIS_NAMES:
                        axis_range = self.volume.get(self.name)
                        if axis_range[1] is None or self.max_item > axis_range[1]:
                            axis_range[1] = self.max_item
                item_path_no_suffix = os.path.join(self.parent_dir,
                    prefix_dir, item + '_{0}'.format(item_num))
                _, ext = os.path.splitext(item_path)
                #print('item_path_no_suffix', prefix_dir, item_path_no_suffix)
                self.paths[item_num] = item_path_no_suffix
                if (os.path.isfile(item_path) and self.image_w is None
                        and ext.lower() in ('.png', '.jpg')):
                    with Image.open(item_path) as img:
                        image_w, image_h = img.size
                    if self.image_w is None or image_w > self.image_w:
                        self.image_w = image_w
                    if self.image_h is None or image_h > self.image_h:
                        self.image_h = image_h
            if self.path_template is None:
                if is_split_folder:
                    prefix_dir = re.sub('^(\d+)$', '{{{0} // 100 % 10}}'.format(item),
                        prefix_dir)
                self.path_template = os.path.normpath(os.path.join(prefix_dir,
                    item + '_{0}'.format('{' + item + '}')))
                #print('path_template', self.path_template)

    def reverse_paths(self):
        if self.name in AXIS_NAMES:
            start_range, end_range = self.volume.get(self.name)
        else:
            start_range, end_range = self.min_item, self.max_item
        new_paths = {}
        for name, path in self.paths.items():
            new_name = end_range - name + start_range
            new_paths[new_name] = path
        self.paths = new_paths

    def get_relpaths(self):
        return ((name, os.path.relpath(path, self.root.path))
            for name, path in self.paths.items())

    def define_subaxis(self, subaxis_name, subaxis_path, item):
        subaxis_config = self.config and self.config.get(subaxis_name, {}) or {}
        if not subaxis_config:
            key_match = None
            for key in self.config.keys():
                if re.match(r'^all(.*)\*$', key):
                    key_match = key
                    subaxis_config = self.config.get(key, {})
                    break
        #print('define_subaxis', subaxis_name, 'config', subaxis_config)
        axis = self.subaxes[subaxis_name] = ImageAxis(subaxis_name,
            self.volume, subaxis_path, item, subaxis_config,
            _parent_axis=self)
        return axis

    def get_subaxis(self, subaxis_name):
        return self.subaxes.get(subaxis_name)

    def get_full_path_template(self, *extra_paths, **keywords):
        full_path_template = ''
        last_axis = axis = self
        while axis:
            last_axis = axis
            try:
                path_template = axis.path_template.format(**keywords)
            except KeyError:
                path_template = axis.path_template
            #print('add template', path_template)
            full_path_template = os.path.join(path_template, full_path_template)
            axis = axis._parent_axis
        full_path_template = os.path.join(last_axis._parent.path,
            full_path_template, *extra_paths)
        #print('full_path_template', full_path_template)
        full_path_template = os.path.relpath(full_path_template, self.root.path)
        #print('final template', full_path_template)
        return full_path_template

    def get_rel_path_template(self, parent_axis, rel_path, *extra_paths, **keywords):
        rel_path_template = ''
        axis = self
        #Build the template string from right to left
        #The path_template of the parent axis is prepended until the final 'parent_axis'
        #These path templates can be optionally replaced with **keywords
        #while axis and os.path.relpath(axis.path, self.root.path) != common_path:
        while axis and axis != parent_axis:
            #print(self.name, 'axis is', axis.name)
            try:
                path_template = axis.path_template.format(**keywords)
            except KeyError:
                path_template = axis.path_template
            #print(self.name, 'prepend', path_template)
            rel_path_template = os.path.join(path_template, rel_path_template)
            axis = axis._parent_axis
        rel_path_template = os.path.join(rel_path, rel_path_template, *extra_paths)
        rel_path_template = os.path.normpath(rel_path_template)
        return rel_path_template

    def get_attributes(self):
        return _check_attributes(self.config, self.parent_dir)

    def get_config(self, key=None, default=None):
        if key is None:
            return self.config
        return self.config.get(key, default)

    def __repr__(self):
         return ('<ImageAxis name={0} path={1} config={2} prefix_dir={3} '
             'parent_dir={4} item={5} min_item={6} max_item={7} image_w={8} image_h={9} '
             'path_template={10} len(paths)={11} subaxes={12}>').format(
             self.name, self.path, self.config, self.prefix_dir,
             self.parent_dir, self.item, self.min_item, self.max_item, self.image_w, self.image_h,
             self.path_template, len(self.paths), self.subaxes)

    def get_pp_obj(self):
        subaxes_o = {}
        for subaxis_name, subaxis in self.subaxes.items():
            subaxes_o[subaxis_name] = subaxis.get_pp_obj()
        return ['ImageAxis', ('name', self.name), ('path', self.path), ('config', self.config),
            ('prefix_dir', self.prefix_dir), ('parent_dir', self.parent_dir), ('item', self.item),
            ('min_item', self.min_item), ('max_item', self.max_item),
            ('image_w', self.image_w), ('image_h', self.image_h),
            ('path_template', self.path_template),
            # ('paths', self.paths),
            ('subaxes', subaxes_o)]

QUERY_RECREATE_DB = """
DROP TABLE IF EXISTS "glyph_slice";
DROP TABLE IF EXISTS "glyph_session";
DROP TABLE IF EXISTS "glyph_modality";
DROP TABLE IF EXISTS "glyph_type";
DROP TABLE IF EXISTS "label_slice";
DROP TABLE IF EXISTS "label_volume_axis";
DROP TABLE IF EXISTS "label_modality";
DROP TABLE IF EXISTS "label_type";
DROP TABLE IF EXISTS "aggregate_mr_slice";
DROP TABLE IF EXISTS "aggregate_mr_volume_axis";
DROP TABLE IF EXISTS "aggregate_mr_modality";
DROP TABLE IF EXISTS "aggregate_mr_type";
DROP TABLE IF EXISTS "mr_slice";
DROP TABLE IF EXISTS "mr_volume_axis";
DROP TABLE IF EXISTS "mr_session";
DROP TABLE IF EXISTS "mr_modality";
DROP TABLE IF EXISTS "mr_type";
DROP TABLE IF EXISTS "histology_slice";
DROP TABLE IF EXISTS "histology_level";
DROP TABLE IF EXISTS "histology_modality";
DROP TABLE IF EXISTS "histology_stain";
DROP TABLE IF EXISTS "block_slice";
DROP TABLE IF EXISTS "block_modality";
DROP TABLE IF EXISTS "modality_attributes";
DROP TABLE IF EXISTS "modality";
DROP TABLE IF EXISTS "subject_meta";
DROP TABLE IF EXISTS "subject_volume_axis";
DROP TABLE IF EXISTS "axis";
DROP TABLE IF EXISTS "subject";

CREATE TABLE "subject" (
    subject_id BIGSERIAL PRIMARY KEY,
    subject TEXT NOT NULL,
    display_name TEXT NOT NULL,
    ui_id BIGSERIAL NOT NULL,
    unique (subject),
    unique (display_name),
    unique (ui_id)
);

CREATE TABLE "axis" (
    axis_id SERIAL PRIMARY KEY,
    axis TEXT NOT NULL,
    unique(axis)
);

CREATE TABLE "subject_volume_axis" (
    subject_id BIGINT NOT NULL,
    axis_id INT NOT NULL,
    start_range INT NOT NULL,
    end_range INT NOT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (axis_id) REFERENCES "axis" (axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(subject_id, axis_id)
);

CREATE TABLE "subject_meta" (
    default_ui_id BIGINT NULL,
    FOREIGN KEY (default_ui_id) REFERENCES "subject" (ui_id)
        ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE "modality" (
    modality_id BIGSERIAL PRIMARY KEY,
    modality TEXT NOT NULL,
    unique (modality)
);

CREATE TABLE "modality_attributes" (
    attrib_id BIGSERIAL PRIMARY KEY,
    horizontal_flip SMALLINT NULL,
    vertical_flip SMALLINT NULL,
    rotate TEXT NULL,
    xscale REAL NULL,
    yscale REAL NULL,
    thickness_in_mm REAL NULL
);

CREATE TABLE "block_modality" (
    block_mod_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    image_w INT NOT NULL,
    image_h INT NOT NULL,
    min_slice INT NOT NULL,
    max_slice INT NOT NULL,
    attrib_id BIGINT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (attrib_id) REFERENCES "modality_attributes" (attrib_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    unique (subject_id)
);

CREATE TABLE "block_slice" (
    block_slice_id BIGSERIAL PRIMARY KEY,
    block_mod_id BIGINT NOT NULL,
    slice INT NOT NULL,
    file_path TEXT NULL,
    FOREIGN KEY (block_mod_id) REFERENCES "block_modality" (block_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(block_mod_id, slice)
);

CREATE TABLE "histology_stain" (
    hist_stain_id BIGSERIAL PRIMARY KEY,
    stain TEXT NOT NULL,
    unique (stain)
);

CREATE TABLE "histology_modality" (
    hist_mod_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    hist_stain_id BIGINT NOT NULL,
    magnification_factor INT NOT NULL,
    min_slice INT NOT NULL,
    max_slice INT NOT NULL,
    attrib_id BIGINT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (hist_stain_id) REFERENCES "histology_stain" (hist_stain_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (attrib_id) REFERENCES "modality_attributes" (attrib_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    unique (subject_id, hist_stain_id)
);

CREATE TABLE "histology_level" (
    hist_level_id BIGSERIAL PRIMARY KEY,
    hist_mod_id BIGINT NOT NULL,
    level INT NOT NULL,
    image_w INT NOT NULL,
    image_h INT NOT NULL,
    min_row INT NOT NULL,
    max_row INT NOT NULL,
    min_col INT NOT NULL,
    max_col INT NOT NULL,
    FOREIGN KEY (hist_mod_id) REFERENCES "histology_modality" (hist_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(hist_mod_id, level)
);

CREATE TABLE "histology_slice" (
    hist_slice_id BIGSERIAL PRIMARY KEY,
    hist_mod_id BIGINT NOT NULL,
    slice INT NOT NULL,
    file_path_template TEXT NULL,
    preview_path_template TEXT NULL,
    FOREIGN KEY (hist_mod_id) REFERENCES "histology_modality" (hist_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(hist_mod_id, slice)
);

CREATE TABLE "mr_type" (
    mr_type_id BIGSERIAL PRIMARY KEY,
    mr_type TEXT NOT NULL,
    has_volumes SMALLINT NOT NULL,
    unique(mr_type)
);

CREATE TABLE "mr_modality" (
    mr_mod_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    mr_type_id BIGINT NOT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (mr_type_id) REFERENCES "mr_type" (mr_type_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique (subject_id, mr_type_id)
);

CREATE TABLE "mr_session" (
    mr_session_id BIGSERIAL PRIMARY KEY,
    mr_mod_id BIGINT NOT NULL,
    session INT NULL,
    invivo SMALLINT NOT NULL
        CHECK (invivo = cast(0 as smallint) OR invivo = cast(1 as smallint)),
    volume INT NULL,
    FOREIGN KEY (mr_mod_id) REFERENCES "mr_modality" (mr_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(mr_mod_id, session, invivo, volume)
);

CREATE TABLE "mr_volume_axis" (
    mr_vol_axis_id BIGSERIAL PRIMARY KEY,
    mr_session_id BIGINT NOT NULL,
    axis_id INT NOT NULL,
    image_w INT NOT NULL,
    image_h INT NOT NULL,
    min_slice INT NOT NULL,
    max_slice INT NOT NULL,
    attrib_id BIGINT NULL,
    FOREIGN KEY (mr_session_id) REFERENCES "mr_session" (mr_session_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (axis_id) REFERENCES "axis" (axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (attrib_id) REFERENCES "modality_attributes" (attrib_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    unique(mr_session_id, axis_id)
);

CREATE TABLE "mr_slice" (
    mr_slice_id BIGSERIAL PRIMARY KEY,
    mr_vol_axis_id BIGINT NOT NULL,
    slice INT NOT NULL,
    file_path TEXT NULL,
    FOREIGN KEY (mr_vol_axis_id) REFERENCES "mr_volume_axis" (mr_vol_axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(mr_vol_axis_id, slice)
);

CREATE TABLE "aggregate_mr_type" (
    amr_type_id BIGSERIAL PRIMARY KEY,
    amr_type TEXT NOT NULL,
    unique(amr_type)
);

CREATE TABLE "aggregate_mr_modality" (
    amr_mod_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    amr_type_id BIGINT NOT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (amr_type_id) REFERENCES "aggregate_mr_type" (amr_type_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique (subject_id, amr_type_id)
);

CREATE TABLE "aggregate_mr_volume_axis" (
    amr_vol_axis_id BIGSERIAL PRIMARY KEY,
    amr_mod_id BIGINT NOT NULL,
    axis_id INT NOT NULL,
    image_w INT NOT NULL,
    image_h INT NOT NULL,
    min_slice INT NOT NULL,
    max_slice INT NOT NULL,
    attrib_id BIGINT NULL,
    FOREIGN KEY (amr_mod_id) REFERENCES "aggregate_mr_modality" (amr_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (axis_id) REFERENCES "axis" (axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (attrib_id) REFERENCES "modality_attributes" (attrib_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    unique(amr_mod_id, axis_id)
);

CREATE TABLE "aggregate_mr_slice" (
    amr_slice_id BIGSERIAL PRIMARY KEY,
    amr_vol_axis_id BIGINT NOT NULL,
    slice INT NOT NULL,
    file_path TEXT NULL,
    FOREIGN KEY (amr_vol_axis_id) REFERENCES "aggregate_mr_volume_axis" (amr_vol_axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(amr_vol_axis_id, slice)
);

CREATE TABLE "label_type" (
    label_type_id BIGSERIAL PRIMARY KEY,
    label_type TEXT NOT NULL,
    unique(label_type)
);

CREATE TABLE "label_modality" (
    label_mod_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    label_type_id BIGINT NOT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (label_type_id) REFERENCES "label_type" (label_type_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique (subject_id, label_type_id)
);

CREATE TABLE "label_volume_axis" (
    label_vol_axis_id BIGSERIAL PRIMARY KEY,
    label_mod_id BIGINT NOT NULL,
    axis_id INT NOT NULL,
    image_w INT NOT NULL,
    image_h INT NOT NULL,
    min_slice INT NOT NULL,
    max_slice INT NOT NULL,
    attrib_id BIGINT NULL,
    FOREIGN KEY (label_mod_id) REFERENCES "label_modality" (label_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (axis_id) REFERENCES "axis" (axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (attrib_id) REFERENCES "modality_attributes" (attrib_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    unique(label_mod_id, axis_id)
);

CREATE TABLE "label_slice" (
    label_slice_id BIGSERIAL PRIMARY KEY,
    label_vol_axis_id BIGINT NOT NULL,
    slice INT NOT NULL,
    file_path TEXT NULL,
    contour_file_path TEXT NULL,
    FOREIGN KEY (label_vol_axis_id) REFERENCES "label_volume_axis" (label_vol_axis_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(label_vol_axis_id, slice)
);

CREATE TABLE "glyph_type" (
    glyph_type_id BIGSERIAL PRIMARY KEY,
    glyph_type TEXT NOT NULL,
    unique(glyph_type)
);

CREATE TABLE "glyph_modality" (
    glyph_mod_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    glyph_type_id BIGINT NOT NULL,
    FOREIGN KEY (subject_id) REFERENCES "subject" (subject_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (glyph_type_id) REFERENCES "glyph_type" (glyph_type_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(subject_id, glyph_type_id)
);

CREATE TABLE "glyph_session" (
    glyph_session_id BIGSERIAL PRIMARY KEY,
    glyph_mod_id BIGINT NOT NULL,
    session INT NOT NULL,
    invivo SMALLINT NOT NULL
        CHECK (invivo = cast(0 as smallint) OR invivo = cast(1 as smallint)),
    min_slice INT NOT NULL,
    max_slice INT NOT NULL,
    image_w INT NOT NULL,
    image_h INT NOT NULL,
    min_row INT NOT NULL,
    max_row INT NOT NULL,
    min_col INT NOT NULL,
    max_col INT NOT NULL,
    attrib_id BIGINT NULL,
    FOREIGN KEY (glyph_mod_id) REFERENCES "glyph_modality" (glyph_mod_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (attrib_id) REFERENCES "modality_attributes" (attrib_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    unique(glyph_mod_id, session, invivo)
);

CREATE TABLE "glyph_slice" (
    glyph_slice_id BIGSERIAL PRIMARY KEY,
    glyph_session_id BIGINT NOT NULL,
    slice INT NOT NULL,
    file_path_template TEXT NULL,
    preview_path_template TEXT NULL,
    FOREIGN KEY (glyph_session_id) REFERENCES "glyph_session" (glyph_session_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    unique(glyph_session_id, slice)
);

"""

QUERY_INSERT_MODALITIES = """
INSERT INTO "modality" (modality)
VALUES ('block'), ('hist'), ('mr'), ('labels'), ('glyphs'), ('aggregate_mr');
"""

QUERY_INSERT_HISTOLOGY_STAINS = """
INSERT INTO "histology_stain" (stain)
VALUES ('BDA'), ('myelin'), ('nissl') RETURNING stain, hist_stain_id;
"""

QUERY_INSERT_MR_TYPES = """
INSERT INTO "mr_type" (mr_type, has_volumes)
VALUES ('VR', 1), ('Diffusion_tensor', 1), ('RA', 1), ('VEC1', 1),
('b3000', 1), ('b6000', 1), ('b9000', 1), ('b12000', 1),
('T2', 0), ('Mean_B0', 0), ('FA', 0), ('CMAP', 0), ('Mean_DW', 0), ('MD', 0)
RETURNING mr_type, mr_type_id, has_volumes
"""

QUERY_INSERT_AGGREGATE_MR_TYPES = """
INSERT INTO "aggregate_mr_type" (amr_type)
VALUES ('brainmask'), ('pd-template'), ('t1-template'), ('t2-template'),
('exvivo-fa-template'), ('exvivo-structural-template'),
('invivo-fa-template'), ('invivo-md-template')
RETURNING amr_type, amr_type_id
"""

QUERY_INSERT_GLYPH_TYPES = """
INSERT INTO "glyph_type" (glyph_type)
VALUES ('CSD'), ('DTI') RETURNING glyph_type, glyph_type_id
"""

QUERY_INSERT_SUBJECT = """
INSERT INTO "subject" (subject, display_name)
VALUES (%s, %s) RETURNING subject_id, ui_id
"""

QUERY_INSERT_AXIS = """
INSERT INTO "axis" (axis)
VALUES ('axial'), ('coronal'), ('sagittal') RETURNING axis, axis_id;
"""

QUERY_INSERT_SUBJECT_VOLUME_AXIS = """
INSERT INTO "subject_volume_axis" (subject_id, axis_id, start_range, end_range)
VALUES (%s, %s, %s, %s)
"""

QUERY_INSERT_DEFAULT_SUBJECT = """
INSERT INTO "subject_meta" (default_ui_id)
VALUES (%s) RETURNING default_ui_id
"""

QUERY_INSERT_MODALITY_ATTRIB = """
INSERT INTO "modality_attributes" ({names})
VALUES ({values}) RETURNING attrib_id
"""

QUERY_INSERT_BLOCK_MODALITY = """
INSERT INTO "block_modality" (subject_id, image_w, image_h, min_slice, max_slice, attrib_id)
VALUES (%s, %s, %s, %s, %s, %s) RETURNING block_mod_id
"""

QUERY_INSERT_BLOCK_SLICE = """
INSERT INTO "block_slice" (block_mod_id, slice, file_path)
VALUES %s RETURNING block_slice_id
"""

QUERY_INSERT_HISTOLOGY_MODALITY = """
INSERT INTO "histology_modality" (subject_id, hist_stain_id, magnification_factor, min_slice, max_slice, attrib_id)
VALUES (%s, %s, %s, %s, %s, %s) RETURNING hist_mod_id
"""

QUERY_INSERT_HISTOLOGY_LEVEL = """
INSERT INTO "histology_level" (hist_mod_id, level, image_w, image_h, min_row, max_row, min_col, max_col)
VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING hist_level_id
"""

QUERY_INSERT_HISTOLOGY_SLICE = """
INSERT INTO "histology_slice" (hist_mod_id, slice, file_path_template, preview_path_template)
VALUES %s RETURNING hist_slice_id
"""

QUERY_INSERT_MR_MODALITY = """
INSERT INTO "mr_modality" (subject_id, mr_type_id)
VALUES (%s, %s) RETURNING mr_mod_id
"""

QUERY_INSERT_MR_SESSION = """
INSERT INTO "mr_session" (mr_mod_id, session, invivo, volume)
VALUES (%s, %s, %s, %s) RETURNING mr_session_id
"""

QUERY_INSERT_MR_VOLUME_AXIS = """
INSERT INTO "mr_volume_axis" (mr_session_id, axis_id, image_w, image_h, min_slice, max_slice, attrib_id)
VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING mr_vol_axis_id
"""

QUERY_INSERT_MR_SLICE = """
INSERT INTO "mr_slice" (mr_vol_axis_id, slice, file_path)
VALUES %s RETURNING mr_slice_id
"""

QUERY_INSERT_LABEL_TYPES = """
INSERT INTO "label_type" (label_type)
VALUES ('roi'), ('BDAcount'), ('MR') RETURNING label_type, label_type_id
"""

QUERY_INSERT_LABEL_MODALITY = """
INSERT INTO "label_modality" (subject_id, label_type_id)
VALUES (%s, %s) RETURNING label_mod_id
"""

QUERY_INSERT_LABEL_VOLUME_AXIS = """
INSERT INTO "label_volume_axis" (label_mod_id, axis_id, image_w, image_h, min_slice, max_slice, attrib_id)
VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING label_vol_axis_id
"""

QUERY_INSERT_LABEL_SLICE = """
INSERT INTO "label_slice" (label_vol_axis_id, slice, file_path, contour_file_path)
VALUES %s RETURNING label_slice_id
"""

QUERY_INSERT_GLYPH_MODALITY = """
INSERT INTO "glyph_modality" (subject_id, glyph_type_id)
VALUES (%s, %s) RETURNING glyph_mod_id
"""

QUERY_INSERT_GLYPH_SESSION = """
INSERT INTO "glyph_session" (glyph_mod_id, session, invivo, min_slice, max_slice, image_w, image_h,
min_row, max_row, min_col, max_col, attrib_id)
VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING glyph_session_id
"""

QUERY_INSERT_GLYPH_SLICE = """
INSERT INTO "glyph_slice" (glyph_session_id, slice, file_path_template, preview_path_template)
VALUES %s RETURNING glyph_slice_id
"""

QUERY_INSERT_AGGREGATE_MR_MODALITY = """
INSERT INTO "aggregate_mr_modality" (subject_id, amr_type_id)
VALUES (%s, %s) RETURNING amr_mod_id
"""

QUERY_INSERT_AGGREGATE_MR_VOLUME_AXIS = """
INSERT INTO "aggregate_mr_volume_axis" (amr_mod_id, axis_id, image_w, image_h, min_slice, max_slice, attrib_id)
VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING amr_vol_axis_id
"""

QUERY_INSERT_AGGREGATE_MR_SLICE = """
INSERT INTO "aggregate_mr_slice" (amr_vol_axis_id, slice, file_path)
VALUES %s RETURNING amr_slice_id
"""

ATLAS_ROOT = None

MODALITIES = {}

HIST_STAINS = {}

MR_TYPES = {}

AXIS = {}

LABEL_TYPES = {}

GLYPH_TYPES = {}

AGGREGATE_MR_TYPES = {}

PAGE_SIZE = 1000

AXIS_NAMES = ('coronal', 'axial', 'sagittal')

def validate_rotate(val):
    m = re.search('(\w+) (\d+)', val)
    if m:
        verb, angle = m.group(1), m.group(2)
        verb = verb.lower()
        if verb in ('right', 'left'):
            try:
                angle = int(angle)
                if angle >= 0 and angle < 360:
                    return '{0} {1}'.format(verb, angle)
            except ValueError:
                pass
    raise ValueError('Invalid rotation value: "{0}". Must be of the '
        'format "{{verb}} {{angle}}", where {{verb}} is either "right" or '
        '"left", and 0 <= {{angle}} < 360'.format(val))


#The following are valid values that can be in the attr.yaml.
VALID_ATTRS = {
    'horizontal_flip': int,
    'vertical_flip': int,
    'rotate': validate_rotate,
    'xscale': float,
    'yscale': float,
    'thickness_in_mm': float,
}

def get_meta_data(root_path, subject_list, modality_list, no_ask_pass):
    try:
        import memcache
        memcached_host = _config.get('cache', 'memcache_host')
        memcached_port = _config.get('cache', 'memcache_port')
        cache = memcache.Client((memcached_host, memcached_port))
    except ImportError as e:
        print('Can not update memcache:', e)
        cache = None
    atlas_root = AtlasRoot(root_path)
    #Read the configuration
    meta_config_path = os.path.join(root_path, 'smda.yaml')
    meta_config = read_config(meta_config_path)
    config_default_subject = meta_config.get('default_subject')
    default_subject = None
    default_by = None
    #Open the database
    database_password = None
    if not no_ask_pass:
        database_password = getpass.getpass('Enter database password:')
    if not database_password:
        db_config = configparser.ConfigParser()
        db_config.read('/opt/smda/smda-db.cfg')
        try:
            connect_str = db_config.get('database', 'connect_str')
        except configparser.NoSectionError:
            connect_str = None
        if connect_str:
            m = re.search('password=(.*)', connect_str)
            if m:
                database_password = m.group(1)
    if not database_password:
        database_password = 'XXXX'
    connect_str = 'dbname=smda user=smda password={0}'.format(database_password)
    with psycopg2.connect(connect_str) as db_conn:
        c = db_conn.cursor()
        c.execute(QUERY_RECREATE_DB)
        c.execute(QUERY_INSERT_MODALITIES)
        c.execute(QUERY_INSERT_HISTOLOGY_STAINS)
        HIST_STAINS.update(c.fetchall())
        c.execute(QUERY_INSERT_MR_TYPES)
        MR_TYPES.update((x[0], x[1:]) for x in c.fetchall())
        c.execute(QUERY_INSERT_AXIS)
        AXIS.update(c.fetchall())
        c.execute(QUERY_INSERT_LABEL_TYPES)
        LABEL_TYPES.update((x[0], x[1:]) for x in c.fetchall())
        c.execute(QUERY_INSERT_GLYPH_TYPES)
        GLYPH_TYPES.update((x[0], x[1]) for x in c.fetchall())
        c.execute(QUERY_INSERT_AGGREGATE_MR_TYPES)
        AGGREGATE_MR_TYPES.update((x[0], x[1:]) for x in c.fetchall())
        #Scan each subject folder
        for subject_name in subject_list:
            subject_path = os.path.join(root_path, subject_name)
            if not os.path.isdir(subject_path):
                continue
            subject_config_path = os.path.join(subject_path, 'config.yaml')
            #Get the subject configuration and volume size
            config = read_config(subject_config_path)
            display_name = config.get('display_name', subject_name)
            c.execute(QUERY_INSERT_SUBJECT, (subject_name, display_name))
            subject_id, ui_id = c.fetchone()
            subject = atlas_root.add_subject(subject_name, display_name,
                subject_id, ui_id)
            modality_nodes = define_modality_nodes(subject, subject_path,
                modality_list, config)
            if subject_name == config_default_subject:
                default_subject = subject
                default_by = 'configuration'
            for axis, rnge in subject.volume.items():
                start_range, end_range = rnge
                if start_range and end_range:
                    axis_id = AXIS[axis]
                    #print('insert', subject_id, axis_id, start_range, end_range)
                    c.execute(QUERY_INSERT_SUBJECT_VOLUME_AXIS, (subject_id,
                        axis_id, start_range, end_range))
            #Get the meta-information from the modalities
            get_modality_data(db_conn, subject)
            if cache:
                cache.delete('subject_info[{0}]'.format(ui_id))
        print('subjects:')
        for subject in atlas_root.subjects.values():
            print('{0} -> display_name: {1}, ui_id: {2}, volume: {3}'.format(
                subject.name, subject.display_name, subject.ui_id,
                subject.volume))
        #pprint.pprint(atlas_root.subjects)
        #pprint.pprint(atlas_root.get_pp_obj())
        if atlas_root.subjects:
            #The default subject is the one specified in the configuration
            #If not specified, then the default is the first subject
            if not default_subject:
                first_subject = next(iter(atlas_root.subjects.keys()))
                default_subject = atlas_root.subjects[first_subject]
                default_by = 'first subject'
            ui_id = default_subject.ui_id
            if ui_id:
                c.execute(QUERY_INSERT_DEFAULT_SUBJECT, (ui_id,))
                print('set default subject to', default_subject.name,
                    'by', default_by)
    return None

def define_modality_nodes(subject, subject_path, modality_list, config):
    #Explore each folder to get the true volume
    modality_table = {
        'block': define_modality_block,
        'hist': define_modality_hist,
        'MR': define_modality_mr,
        'aggregateMR': define_modality_aggregate_mr,
        'labels': define_modality_label,
        'glyphs': define_modality_glyph,
    }
    for modality_name in os.listdir(subject_path):
        if modality_name not in modality_list:
            continue
        modality_config = config.get(modality_name, {})
        if modality_config.get('skip', False):
            continue
        path = os.path.join(subject_path, modality_name)
        rule = modality_table.get(modality_name)
        if rule:
            rule(subject, path, modality_config)
    return subject.modalities

def get_modality_data(db_conn, subject):
    modality_table = {
        'block': get_block_data,
        'hist': get_hist_data,
        'MR': get_mr_data,
        'aggregateMR': get_aggregate_mr_data,
        'label': get_label_data,
        'glyph': get_glyph_data,
    }
    for modality in subject.modalities.values():
        rule = modality_table.get(modality.name)
        if rule:
            print('subject', subject.name)
            print('display name', subject.display_name)
            rule(db_conn, modality)
    return None

def _check_attributes(attributes, namespace=None):
    new_attrib = {}
    if attributes:
        for key, val in attributes.items():
            if key in VALID_ATTRS:
                convert = VALID_ATTRS[key]
                try:
                    new_attrib[key] = convert(val)
                except ValueError as e:
                    print('error parsing attributes while converting '
                        '"{0}:{1}" : {2}'.format(namespace, key, e),
                        file=sys.stderr)
                    sys.exit(1)
    return new_attrib

def _insert_attribute_row(db_conn, attributes, namespace=None):
    attrib_id = None
    if attributes:
        c = db_conn.cursor()
        names = []
        values = []
        for name, value in attributes.items():
            names.append(name)
            values.append("'{0}'".format(value) if isinstance(value, str)
                else value)
        query = QUERY_INSERT_MODALITY_ATTRIB.format(names=','.join(names),
            values=','.join(str(v) for v in values))
        c.execute(query)
        attrib_id = c.fetchone()[0]
    return attrib_id

def define_modality_block(subject, block_path, block_config):
    print('scanning:', block_path, '...')
    modality = subject.define_modality('block', block_path, block_config)
    if modality.config.get('skip', False):
        print('skipping block')
        return None
    slice_axis = modality.define_axis('coronal', block_path, 'slice')

def get_block_data(db_conn, modality):
    print('update meta:', modality.path)
    slice_axis = modality.get_axis('coronal')
    if slice_axis.get_config('reverse_slices', False):
        print('reversing block slices')
        slice_axis.reverse_paths()
    attrib_id = _insert_attribute_row(db_conn, slice_axis.get_attributes())
    c = db_conn.cursor()
    c.execute(QUERY_INSERT_BLOCK_MODALITY, (modality.subject.id,
        slice_axis.image_w, slice_axis.image_h,
        slice_axis.min_item, slice_axis.max_item, attrib_id))
    block_mod_id = c.fetchone()[0]
    slices = [(block_mod_id, sl, img_path)
        for sl, img_path in slice_axis.get_relpaths()]
    psycopg2.extras.execute_values(c, QUERY_INSERT_BLOCK_SLICE,
        slices, page_size=PAGE_SIZE)

def define_modality_hist(subject, hist_path, hist_config):
    print('scanning:', hist_path, '...')
    modality = subject.define_modality('hist', hist_path, hist_config)
    for stain in os.listdir(hist_path):
        if stain not in HIST_STAINS:
            continue
        stain_config = hist_config.get(stain, {})
        if stain_config.get('skip', False):
            print('skipping', stain)
            continue
        stain_path = os.path.join(hist_path, stain)
        stain_axis = modality.define_axis(stain, stain_path, '')
        slice_axis = stain_axis.define_subaxis('coronal', stain_path, 'slice')
        #For the first slice, create a subaxis for every level
        #For every level, create a subaxis for the first row and column
        for sl, slice_path in slice_axis.paths.items():
            level_axis = slice_axis.define_subaxis('level', slice_path,
                'level')
            for level, level_path in level_axis.paths.items():
                row_axis = level_axis.define_subaxis(level, level_path, 'row')
                for col, col_path in row_axis.paths.items():
                    col_axis = row_axis.define_subaxis('column', col_path,
                        'col')
                    break
            break

def get_hist_data(db_conn, modality):
    c = db_conn.cursor()
    for stain, stain_axis in modality.axes.items():
        #Get the slice information
        slice_axis = stain_axis.get_subaxis('coronal')
        print('update meta:', slice_axis.path)
        if slice_axis.get_config('reverse_slices', False):
            print('reversing', stain, 'histology slices')
            slice_axis.reverse_paths()
        attrib_id = _insert_attribute_row(db_conn, slice_axis.get_attributes())
        hist_stain_id = HIST_STAINS[stain]
        c.execute(QUERY_INSERT_HISTOLOGY_MODALITY, (modality.subject.id,
            hist_stain_id, HIST_MAGNIFICATION_FACTOR, slice_axis.min_item,
            slice_axis.max_item, attrib_id))
        hist_mod_id = c.fetchone()[0]
        #Insert each histology level
        level_axis = slice_axis.subaxes['level']
        if level_axis.paths:
            for level, row_axis in level_axis.subaxes.items():
                col_axis = row_axis.subaxes['column']
                c.execute(QUERY_INSERT_HISTOLOGY_LEVEL, (hist_mod_id, level,
                    col_axis.image_w, col_axis.image_h,
                    row_axis.min_item, row_axis.max_item,
                    col_axis.min_item, col_axis.max_item))
            #Insert histology slices
            slices = [((hist_mod_id, sl,
                col_axis.get_rel_path_template(slice_axis, img_path),
                level_axis.get_rel_path_template(slice_axis, img_path, 'preview')))
                for sl, img_path in slice_axis.get_relpaths()]
            psycopg2.extras.execute_values(c, QUERY_INSERT_HISTOLOGY_SLICE,
                slices, page_size=PAGE_SIZE)

def define_modality_mr(subject, mr_path, mr_config):
    print('scanning:', mr_path, '...')
    modality = subject.define_modality('MR', mr_path, mr_config)
    for mode_name in os.listdir(mr_path):
        if mode_name not in MR_TYPES:
            continue
        mode_config = modality.config.get(mode_name, {})
        if mode_config.get('skip', False):
            print('skipping', mode_name)
            continue
        mode_path = os.path.join(mr_path, mode_name)
        _, has_volumes = MR_TYPES[mode_name]  # Check if this modality has multiple volumes
        mr_axis = modality.define_axis(mode_name, mode_path, '')
        volumes = os.listdir(mode_path)
        #Check if there is a limit on what volumes should be processed
        limit = mode_config.get('limit_volumes')
        if limit:
            limit = str(limit)
            volumes = list(filter(lambda x: x == limit, volumes))
            print(mode_name, 'limit volumes:', limit)
        for volume in volumes:
            volume_path = os.path.join(mode_path, volume)
            volume_axis = mr_axis.define_subaxis(
                has_volumes and volume or None, volume_path, '')
            for vivo in os.listdir(volume_path):
                if vivo not in ('invivo', 'exvivo'):
                    continue
                vivo_path = os.path.join(volume_path, vivo)
                for session in os.listdir(vivo_path):
                    session_name = vivo + '-' + session
                    session_path = os.path.join(vivo_path, session)
                    session_axis = volume_axis.define_subaxis(session_name,
                        session_path, '')
                    for axis_name in os.listdir(session_path):
                        if axis_name not in AXIS_NAMES:
                            continue
                        slice_path = os.path.join(session_path, axis_name)
                        slice_axis = session_axis.define_subaxis(axis_name,
                            slice_path, 'slice')

def get_mr_data(db_conn, modality):
    c = db_conn.cursor()
    for mode_name, mr_axis in modality.axes.items():
        print('update meta:', mr_axis.path)
        mr_type_id, _ = MR_TYPES[mode_name]
        c.execute(QUERY_INSERT_MR_MODALITY, (modality.subject.id,
            mr_type_id))
        mr_mod_id = c.fetchone()[0]
        for volume, volume_axis in mr_axis.subaxes.items():
            for session_name, session_axis in volume_axis.subaxes.items():
                vivo, session = session_name.split('-')
                invivo = 1 if vivo == 'invivo' else 0
                c.execute(QUERY_INSERT_MR_SESSION,
                    (mr_mod_id, session, invivo, volume))
                mr_session_id = c.fetchone()[0]
                for axis_name, slice_axis in session_axis.subaxes.items():
                    axis_id = AXIS[axis_name]
                    attrib_id = _insert_attribute_row(db_conn,
                        slice_axis.get_attributes())
                    c.execute(QUERY_INSERT_MR_VOLUME_AXIS, (mr_session_id,
                        axis_id, slice_axis.image_w, slice_axis.image_h,
                        slice_axis.min_item, slice_axis.max_item, attrib_id))
                    mr_vol_axis_id = c.fetchone()[0]
                    if slice_axis.get_config('reverse_slices', False):
                        s = [mode_name, axis_name, vivo, session, 'slices']
                        if volume:
                            s = ['volume', volume] + s
                        print('reversing', *s)
                        slice_axis.reverse_paths()
                    slices = [(mr_vol_axis_id, sl, img_path)
                        for sl, img_path in slice_axis.get_relpaths()]
                    psycopg2.extras.execute_values(c, QUERY_INSERT_MR_SLICE,
                        slices, page_size=PAGE_SIZE)

def define_modality_aggregate_mr(subject, amr_path, amr_config):
    print('scanning:', amr_path, '...')
    modality = subject.define_modality('aggregateMR', amr_path, amr_config)
    for mode_name in os.listdir(amr_path):
        match = re.search('(.*)-template|brainmask', mode_name)
        if not match:
            continue
        #name = match.group(1)
        amr_config = modality.config.get(mode_name, {})
        if amr_config.get('skip', False):
            print('skipping', mode_name)
            continue
        type_path = os.path.join(amr_path, mode_name)
        mr_axis = modality.define_axis(mode_name, type_path, '')
        for axis_name in AXIS_NAMES:
            axis_path = os.path.join(type_path, axis_name)
            slice_axis = mr_axis.define_subaxis(axis_name, axis_path, 'slice')

def get_aggregate_mr_data(db_conn, modality):
    c = db_conn.cursor()
    for type_name, amr_axis in modality.axes.items():
        print('update meta:', amr_axis.path)
        amr_type_id = AGGREGATE_MR_TYPES[type_name]
        c.execute(QUERY_INSERT_AGGREGATE_MR_MODALITY,
            (modality.subject.id, amr_type_id))
        amr_mod_id = c.fetchone()[0]
        for axis_name, slice_axis in amr_axis.subaxes.items():
            axis_id = AXIS[axis_name]
            attrib_id = _insert_attribute_row(db_conn,
                slice_axis.get_attributes())
            c.execute(QUERY_INSERT_AGGREGATE_MR_VOLUME_AXIS, (amr_mod_id,
                axis_id, slice_axis.image_w, slice_axis.image_h,
                slice_axis.min_item, slice_axis.max_item, attrib_id))
            amr_vol_axis_id = c.fetchone()[0]
            if axis_name in slice_axis.get_config('reverse_slices', []):
                s = [type_name, axis_name, 'slices']
                print('reversing', *s)
                slice_axis.reverse_paths()
            slices = ((amr_vol_axis_id, sl, img_path)
                for sl, img_path in slice_axis.get_relpaths())
            psycopg2.extras.execute_values(c, QUERY_INSERT_AGGREGATE_MR_SLICE,
                slices, page_size=PAGE_SIZE)

def define_modality_label(subject, label_path, label_config):
    print('scanning:', label_path, '...')
    modality = subject.define_modality('label', label_path, label_config)
    for label_type in os.listdir(label_path):
        if label_type not in LABEL_TYPES:
            continue
        label_config = modality.config.get(label_type, {})
        if label_config.get('skip', False):
            print('skipping', label_type)
            continue
        label_type_path = os.path.join(label_path, label_type)
        label_axis = modality.define_axis(label_type, label_type_path, '')
        for axis_name in AXIS_NAMES:
            axis_path = os.path.join(label_type_path, axis_name)
            slice_axis = label_axis.define_subaxis(axis_name, axis_path,
                'slice')

def get_label_data(db_conn, modality):
    c = db_conn.cursor()
    for label_type, label_type_axis in modality.axes.items():
        print('update meta:', label_type_axis.path)
        label_type_id = LABEL_TYPES[label_type]
        c.execute(QUERY_INSERT_LABEL_MODALITY, (modality.subject.id,
            label_type_id))
        label_mod_id = c.fetchone()[0]
        for axis_name, slice_axis in label_type_axis.subaxes.items():
            axis_id = AXIS[axis_name]
            attrib_id = _insert_attribute_row(db_conn,
                slice_axis.get_attributes())
            c.execute(QUERY_INSERT_LABEL_VOLUME_AXIS, (label_mod_id,
                axis_id, slice_axis.image_w, slice_axis.image_h,
                slice_axis.min_item, slice_axis.max_item, attrib_id))
            label_vol_axis_id = c.fetchone()[0]
            if slice_axis.get_config('reverse_slices', False):
                print('reversing', label_type, 'label', axis_name, 'slices')
                slice_axis.reverse_paths()
            slices = [(label_vol_axis_id, sl, img_path, _get_contour_path(img_path))
                for sl, img_path in slice_axis.get_relpaths()]
            psycopg2.extras.execute_values(c, QUERY_INSERT_LABEL_SLICE,
                slices, page_size=PAGE_SIZE)

def _get_contour_path(img_path):
    dirname, basename = os.path.split(img_path)
    basename, ext = os.path.splitext(basename)
    contour_path = os.path.join(dirname, 'contours', basename + '.txt')
    return contour_path

def define_modality_glyph(subject, glyph_path, glyph_config):
    print('scanning:', glyph_path, '...')
    modality = subject.define_modality('glyph', glyph_path, glyph_config)
    for glyph_type in os.listdir(glyph_path):
        if glyph_type not in GLYPH_TYPES:
            continue
        glyph_type_config = modality.config.get(glyph_type, {})
        if glyph_type_config.get('skip', False):
            continue
        glyph_type_path = os.path.join(glyph_path, glyph_type)
        glyph_type_axis = modality.define_axis(glyph_type, glyph_type_path,
            '')
        for session_name in os.listdir(glyph_type_path):
            session_path = os.path.join(glyph_type_path, session_name)
            print('session_path:', session_path)
            match = re.search('(.*)-(\d+)', session_name)
            if not match:
                continue
            session_axis = glyph_type_axis.define_subaxis(session_name,
                session_path, '')
            slice_axis = session_axis.define_subaxis('coronal',
                session_path, 'slice')
            #For every slice, create a subaxis for the first row
            #For every row, create a subaxis for the first column
            for sl, slice_path in slice_axis.paths.items():
                row_axis = slice_axis.define_subaxis('row', slice_path, 'row')
                for col, col_path in row_axis.paths.items():
                    col_axis = row_axis.define_subaxis('column', col_path,
                        'col')
                    break
                break

def get_glyph_data(db_conn, modality):
    c = db_conn.cursor()
    for glyph_type, glyph_type_axis in modality.axes.items():
        #Get the slice information
        glyph_type_id = GLYPH_TYPES[glyph_type]
        c.execute(QUERY_INSERT_GLYPH_MODALITY, (modality.subject.id,
            glyph_type_id))
        glyph_mod_id = c.fetchone()[0]
        for session_name, session_axis in glyph_type_axis.subaxes.items():
            print('update meta:', session_axis.path)
            vivo, session = session_name.split('-')
            invivo = 1 if vivo == 'invivo' else 0
            slice_axis = session_axis.get_subaxis('coronal')

            if slice_axis.get_config('reverse_slices', False):
                print('reversing', session_name, 'glyph slices')
                slice_axis.reverse_paths()
            attrib_id = _insert_attribute_row(db_conn, slice_axis.get_attributes())

            #Insert each glyph session
            row_axis = slice_axis.get_subaxis('row')
            col_axis = row_axis.get_subaxis('column')
            c.execute(QUERY_INSERT_GLYPH_SESSION, (glyph_mod_id, session,
                invivo, slice_axis.min_item, slice_axis.max_item,
                col_axis.image_w, col_axis.image_h,
                row_axis.min_item, row_axis.max_item,
                col_axis.min_item, col_axis.max_item, attrib_id))
            session_id = c.fetchone()[0]

            #Insert glyph slices
            slices = [((session_id, sl,
                col_axis.get_rel_path_template(slice_axis, img_path),
                os.path.join(img_path, 'preview')))
                for sl, img_path in slice_axis.get_relpaths()]

            psycopg2.extras.execute_values(c, QUERY_INSERT_GLYPH_SLICE,
                slices, page_size=PAGE_SIZE)

# def get_glyph_data(db_conn, subject, glyphs_path, config):
#     print('glyphs_path:', glyphs_path)
#     start_range, end_range = subject['volume']['coronal']
#     c = db_conn.cursor()
#     c2 = db_conn.cursor()
#     for glyph_type in os.listdir(glyphs_path):
#         glyph_config = config.get('glyphs', {}).get(glyph_type, {})
#         if glyph_config.get('skip', False):
#             continue
#         glyph_path = os.path.join(glyphs_path, glyph_type)
#         print('glyph path:', glyph_path)
#         glyph_type_id = GLYPH_TYPES[glyph_type]
#         c.execute(QUERY_INSERT_GLYPH_MODALITY, (subject['id'], glyph_type_id))
#         glyph_mod_id = c.fetchone()[0]
#         path_sl_range = list(range(start_range, end_range + 1))
#         if glyph_config.get('reverse_slices', False):
#             print('reversing', glyph_type, 'glyph slices')
#             path_sl_range = list(reversed(path_sl_range))
#         for session_name in os.listdir(glyph_path):
#             session_path = os.path.join(glyph_path, session_name)
#             print('session_path:', session_path)
#             match = re.search('(.*)-(\d+)', session_name)
#             if not match:
#                 continue
#             vivo, session = match.group(1, 2)
#             session = int(session)
#             invivo = 1 if vivo == 'invivo' else 0
#             attrib = _check_attributes(glyph_config.get('attrib'),
#                 session_path)
#             attrib_id = _insert_attribute_row(db_conn, attrib)
#             slice_cllt = _get_collection_info(session_path, 'slice')
#             min_slice = slice_cllt.min_item
#             max_slice = slice_cllt.max_item
#             first_slice_path = os.path.join(atlas_root,
#                 slice_cllt.paths[min_slice])
#             row_cllt = _get_collection_info(first_slice_path, 'row',
#                 slice_cllt.path_template)
#             min_row = row_cllt.min_item
#             max_row = row_cllt.max_item
#             first_row_path = os.path.join(atlas_root,
#                 row_cllt.paths[min_row])
#             col_cllt = _get_collection_info(first_row_path, 'col',
#                 row_cllt.path_template)
#             min_col = col_cllt.min_item
#             max_col = col_cllt.max_item
#             image_w = col_cllt.image_w
#             image_h = col_cllt.image_h
#             c2.execute(QUERY_INSERT_GLYPH_SESSION, (glyph_mod_id, session,
#                 invivo, min_slice, max_slice, image_w, image_h,
#                 min_row, max_row, min_col, max_col, attrib_id))
#             session_id = c2.fetchone()[0]
#             images = []
#             for sl, path_sl in zip(range(start_range, end_range + 1), path_sl_range):
#                 if path_sl in slice_cllt.paths:
#                     images.append((session_id, sl,
#                         os.path.join(slice_cllt.path_template.format(slice=path_sl),
#                             'row_{row}', 'col_{col}.png'),
#                         os.path.join(slice_cllt.path_template.format(slice=path_sl),
#                             'preview.png')))
#             psycopg2.extras.execute_values(c2, QUERY_INSERT_GLYPH_SLICE,
#                 images, page_size=PAGE_SIZE)


def read_config(yaml_path):
    config = {}
    try:
        with open(yaml_path, 'r') as f:
            config = yaml.load(f)
            if config is None:
                config = {}
    except IOError as e:
        #File doesn't exist or could not be opened
        if e.errno != errno.ENOENT:
            print('error while opening', yaml_path, ':', e,
                file=sys.stderr)
    except yaml.YAMLError as e:
        print('error while parsing', yaml_path, ':', e,
            file=sys.stderr)
    return config

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--pretty', action='store_true')
    parser.add_argument('--block', action='store_true')
    parser.add_argument('--hist', action='store_true')
    parser.add_argument('--mr', action='store_true')
    parser.add_argument('--label', action='store_true')
    parser.add_argument('--glyph', action='store_true')
    parser.add_argument('--aggregate-mr', action='store_true')
    parser.add_argument('--subject', action='append', type=str)
    parser.add_argument('--info', dest='show_info', action='store_true')
    parser.add_argument('--no-ask-pass', action='store_true')
    parser.add_argument('atlas_root', default='', nargs='?')
    options = parser.parse_args()

    _config = configparser.ConfigParser()
    _config.read('/opt/smda/web_server/smda_web_server.cfg')
    atlas_root = os.path.abspath(options.atlas_root or
        _config.get('atlas', 'root'))

    if options.show_info:
        print('atlas root:', atlas_root)
        sys.exit(0)

    if options.subject:
        subject_list = options.subject
    else:
        subject_list = sorted(os.listdir(atlas_root))

    modality_list = []
    if options.block:
        modality_list.append('block')
    if options.hist:
        modality_list.append('hist')
    if options.mr:
        modality_list.append('MR')
    if options.label:
        modality_list.append('labels')
    if options.glyph:
        modality_list.append('glyphs')
    if options.aggregate_mr:
        modality_list.append('aggregateMR')
    if not modality_list:
        modality_list = ('block', 'hist', 'MR', 'labels',
            'glyphs', 'aggregateMR')

    get_meta_data(atlas_root, subject_list, modality_list,
        options.no_ask_pass)
